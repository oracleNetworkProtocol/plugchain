(window.webpackJsonp=window.webpackJsonp||[]).push([[152],{473:function(t,a,s){"use strict";s.r(a);var e=s(15),n=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"通货膨胀"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#通货膨胀"}},[t._v("#")]),t._v(" 通货膨胀")]),t._v(" "),a("h2",{attrs:{id:"介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[t._v("#")]),t._v(" 介绍")]),t._v(" "),a("p",[t._v("POW 共识网络的激励机制十分简明：一旦新的区块产生，那么区块的产生者将会获得一定数量的 token 和累积的交易费作为出块奖励。Plug Chain 是 POS 区块链网络，这里的奖励生成过程跟 POW 区块链网络类似，但是奖励分配机制复杂很多。")]),t._v(" "),a("p",[t._v("POW 网络中，在每个区块生成期间，所有矿工竞争计算工作证明，最快计算出结果的矿工将成为赢家。实际上，所有失败的矿工都没有向优胜者矿工提供任何积极的帮助或合作，他们只是竞争对手。因此，向获胜者矿工授予所有奖励是合理的。但是，在 POS 区块链网络中，我们不能这样做。因为每个块生成过程都是所有验证人和委托人的协作，这意味着所有这些贡献者应该共享出块收益。至于如何将出块奖励分发给贡献者，我们将在 "),a("RouterLink",{attrs:{to:"/zh/features/distribution.html"}},[t._v("distribution")]),t._v(" 模块中详细解说。")],1),t._v(" "),a("p",[t._v("在 Plug Chain 网络中，奖励有两个来源，一个是区块中打包的交易的交易费；另一个是每个区块中增发的 token，我们把增发的这部分 token 称为"),a("strong",[t._v("通胀")]),t._v("。这里，mint 模块负责"),a("strong",[t._v("通胀")]),t._v("的计算，并把"),a("strong",[t._v("通胀")]),t._v("的 token 添加到奖励池中。")]),t._v(" "),a("h2",{attrs:{id:"计算通胀"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#计算通胀"}},[t._v("#")]),t._v(" 计算通胀")]),t._v(" "),a("h3",{attrs:{id:"区块时间"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#区块时间"}},[t._v("#")]),t._v(" 区块时间")]),t._v(" "),a("p",[t._v("区块时间不是机器时间，因为不同机器的时间不可能完全相同。 他们或多或少一定会有一些偏差，这将导致不确定性。 这里的时间是指BFT时间。 有关详细说明，请参阅 "),a("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/master/docs/spec/consensus/bft-time.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("tendermint bft-time"),a("OutboundLink")],1),t._v("。")]),t._v(" "),a("h3",{attrs:{id:"通胀率"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#通胀率"}},[t._v("#")]),t._v(" 通胀率")]),t._v(" "),a("p",[t._v("genesis 中指定的初始通胀率是 13%，这个值可以通过在 governance 中提交"),a("code",[t._v("参数修改")]),t._v("的提议来修改。相关步骤，请查阅 "),a("RouterLink",{attrs:{to:"/zh/features/governance.html"}},[t._v("governance")]),t._v("。")],1),t._v(" "),a("h3",{attrs:{id:"通胀计算"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#通胀计算"}},[t._v("#")]),t._v(" 通胀计算")]),t._v(" "),a("p",[t._v("通胀计算的公式如下：")]),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[t._v("blockCostTime  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("当前区块的BFT "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("time")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" - "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("上一个区块的BFT "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("time")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nAnnualInflationAmount "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" inflationBasement * inflationRate\nblockInflationAmount "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" AnnualInflationAmount * blockCostTime / "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("year"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[a("code",[t._v("inflationBasement")]),t._v(" 的值被定义在 genesis 文件中. 默认情况下，genesis 里面写入的值是 "),a("code",[t._v("15989000000uplugcn")]),t._v("（159.89亿个 pc，"),a("code",[t._v("1 pc")]),t._v(" 等于 "),a("code",[t._v("1*10^6 uplugcn")]),t._v("）。")]),t._v(" "),a("p",[t._v("假设 "),a("code",[t._v("blockCostTime")]),t._v(" 是5000毫秒，通胀比例 "),a("code",[t._v("inflationRate")]),t._v(" 是 "),a("code",[t._v("13%")]),t._v("，那么这个块增发的 token 数量是 "),a("code",[t._v("329000000uplugcn")]),t._v("（"),a("code",[t._v("329pc")]),t._v("）")]),t._v(" "),a("h2",{attrs:{id:"对用户的影响"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对用户的影响"}},[t._v("#")]),t._v(" 对用户的影响")]),t._v(" "),a("p",[t._v("通胀计算是一个自动过程，没有用户接口能直接干预此过程。每产生一个新的区块，就会增发一定数量的 token，loose tokens 的数量也会因此增加。")]),t._v(" "),a("p",[t._v("这里可以通过 staking 模块命令行和 restful api 来查询总的 "),a("code",[t._v("loose tokens")]),t._v(" 的数量：")]),t._v(" "),a("p",[a("strong",[a("code",[t._v("plugchaind q staking pool")])])]),t._v(" "),a("p",[t._v("这个接口执行速度比较快，但是不能做默克尔证明，因此如果连接不上可信的全节点，请不要使用此接口。")]),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[t._v("plugchaind q staking pool "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("--node")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("plug_node_url"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),a("p",[t._v("示例输出:")]),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[t._v("bonded_tokens: "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"100000000000000000000"')]),t._v("\nnot_bonded_tokens: "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0"')]),t._v("\n")])])]),a("p",[a("strong",[a("code",[t._v("/staking/pool")])])]),t._v(" "),a("p",[t._v("Restful API 的用法请参阅 swagger 文档。")]),t._v(" "),a("p",[t._v("如何运行一个 swagger 节点，请参阅 "),a("RouterLink",{attrs:{to:"/zh/endpoints/grpc-client.html"}},[t._v("wagger 文档")]),t._v("。")],1)])}),[],!1,null,null,null);a.default=n.exports}}]);